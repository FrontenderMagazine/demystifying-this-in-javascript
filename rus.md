# Раскрытие тайны this в JavaScript

В этой статье я хочу пролить свет на использование `this` в JavaScript и привнести
немного ясности и понимание о том, как `this` работает. Это знание не относится к
чёрной магии и не является запретным, наоборот — понимание `this` чрезвычайно
полезно для вас, как JavaScript-разработчика. Вдохновение для статьи я черпаю из
последней главы из моей будущей книги [Архитектура приложения на JavaScript][2] (вы
можете заказать [раннее издание][3] сейчас) в которой я описываю как работают зоны
видимости.

Пока вы до конца не **осознаете** `this`, вы скорее всего будете чувствовать себя
так:

![Хаос][4]

Это безумие, верно? В этой короткой статье я постараюсь прояснить работу с this.


## Как это работает

Если метод был вызван из объекта, тогда `this` в контексте метода будет ссылкой на
родительский объект.

    var parent = {
        method: function () {
            console.log(this);
        }
    };
    
    parent.method(); // <- родительский объект

Заметьте, что этот паттерн очень уязвим, так как если вы вызовете метод по ссылке,
тогда `this` не будет больше ссылаться на родительский объект `parent`, вместо
этого `this` теперь будет ссылаться на глобальный объект `Window`. Это
обстоятельство приводит в замешательство большинство разработчиков.

    var parentless = parent.method;
    
    parentless(); // <- Window

В последней строчке примера вы должны обратить внимание на то, как вызывается
функция: как свойство объекта или сама по себе. Если вызывается как свойство, то
`this` будет ссылаться на него (!!!), иначе — на глобальный объект; в данном случае
это `Window`, но в [strict mode][5] `this` будет возвращать `undefined`.

В случае конструктора `this` ссылается на созданный экземпляр при условии
использования ключевого слова `new`.

    function ThisClownCar () {
      console.log(this);
    }
    
    new ThisClownCar(); // <- ThisClownCar {}

Стоит заметить сильную неявность поведения `this` в конструкторе: если вы случайно
забудете `new`, то `this` опять будет ссылаться на глобальный объект, как мы уже
наблюдали в примере с `parentless`.

    ThisClownCar();
    // <- Window


## Ручное управление над this

Методы `.call`, `.apply`, и `.bind` используется для управляемого вызова функций,
помогая определять оба передаваемых значения: `this` (контекст функции) и
`arguments`.

Метод `Function.prototype.call` может принимать любое количество аргументов; первый
из них будет использоваться как `this`, а оставшиеся будут переданы вызываемой
функции как аргументы.

    Array.prototype.slice.call([1, 2, 3], 1, 2)
    // <- [2]

Метод `Function.prototype.apply` очень похож на предыдущий, только аргумент в нём
передаются одним массивом, вместо неопределённого количества аргументов у метода
`call`.

    String.prototype.split.apply('13.12.02', ['.'])
    // <- ['13', '12', '02']

Метод `Function.prototype.bind` возвращает специальную функцию, которая может быть
использована для вызова функции, от которой вызван `bind`. Функция всегда будет
использовать переданный ей `this` и в тоже время ей можно передать несколько в
качестве всегда используемых аргументов в возвращаемой функции, что очень удобно
для [каррирования][6] оригинальной функции.

    var arr = [1, 2];
    var add = Array.prototype.push.bind(arr, 3);
    
    // эквивалентно arr.push(3)
    add();
    
    // эквивалентно arr.push(3, 4)
    add(4);
    
    console.log(arr);
    // <- [1, 2, 3, 3, 4]


## Область видимости и this

В следующем случае `this` будет неизменным в разных областях видимости. Это
исключение в правиле и оно часто приводит к ошибкам среди разработчиков. (!!! мне
совсем не нравится этот абзац и пример к нему, они вообще никакой полезной нагрузки
не несут)

    function scoping () {
      console.log(this);
    
      return function () {
        console.log(this);
      };
    }
    
    scoping()();
    // <- Window
    // <- Window

Распространённый способ обойти создавшуюся проблему это создать локальную
переменную, содержащую ссылку на `this` текущей функции (области видимости) и
остающуюся доступной во вложенной функции. Вложенная функция имеет свою собтвенную
переменную `this`, что означает невозможность использования `this` родительской
функции напрямую.

    function retaining () {
      var self = this;
    
      return function () {
        console.log(self);
      };
    }
    
    retaining()();
    // <- Window

Если вы всё таки по каким-то неведомым причинам желаете использовать родительский
контекст (`this` родительской функции), в качестве контекста для вложенной функции,
то я могу посоветовать предпочитаемый мною метод использования функции `.bind`. Эта
функция может быть использована, чтобы пробросить родительский контекст во
вложенную функцию.

    function bound () {
      return function () {
        console.log(this);
      }.bind(this);
    }
    
    bound()();
    // <- Window

## Вопросы?

Были ли у вас какие-нибудь проблемы с этим? А как насчёт `this`? Сообщие мне, если
вы думаете, что я пропустил какие-то важные ситуации или красивые решения.

Если вам понравился этот пост, то возможно вам стоит вам присмотреться к моей
будущей книге «[Архитектура приложения на JavaScript][2]», вы можете заказать
[раннее издание][3] уже сейчас.

[1]: http://flippinawesome.org/authors/nicolas-bevacqua

[2]: http://bevacqua.io/buildfirst "JavaScript Application Design: A Build First Approach"
[3]: http://bevacqua.io/bf/book
[4]: img/chaos.gif

[5]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode "Strict mode explained on MDN"
[6]: http://ru.wikipedia.org/wiki/Каррирование "Каррирование on Wikipedia"
